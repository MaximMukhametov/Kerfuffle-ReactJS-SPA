{"version":3,"sources":["../../src/utils.js","../../src/config.js","../../src/queryCache.js","../../src/setFocusHandler.js","../../src/useIsFetching.js"],"names":["_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","key","a","Array","isDocumentVisible","document","getQueryArgs","args","queryKey","queryFn","Error","config","rest","useMountedCallback","callback","mounted","React","DEFAULTS","shared","suspense","queryKeySerializerFn","invalidQueryKey","d","queryHash","obj","JSON","queries","enabled","retry","retryDelay","attemptIndex","Math","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","deepEqual","b","length","i","keys","onError","onSuccess","onSettled","useErrorBoundary","mutations","throwOnError","onMutate","defaultConfigRef","current","then","subscribe","Promise","result","body","recover","arguments","f","queryCache","makeQueryCache","queryCacheContext","queryCaches","useQueryCache","frozen","defaultConfig","globalListeners","configRef","isFetching","notifyGlobalListeners","query","acc","cb","notify","exact","predicate","deepIncludes","refetchActive","initialData","hasInitialData","isStale","initialStatus","instances","state","queryReducer","undefined","type","action","clearTimeout","setTimeout","instance","onStateUpdate","id","clearInterval","oldConfig","minInterval","setInterval","tryFetchData","promise","delay","reject","resolve","__queryFn","callbackInstances","cancelled","makeQuery","force","newState","status","canFetchMore","failureCount","markedForGarbageCollection","data","updatedAt","Date","switchActions","isLoading","isSuccess","isError","isIdle","onWindowFocus","navigator","useIsFetching","rerender","handleFocus","removePreviousHandler"],"mappings":"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","file":"static/js/5.3f5c98db.chunk.js","sourcesContent":["import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, queryFn, config = {} } = args[0]\n      return [queryKey, queryFn, config, ...args.slice(1)]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n\n  const [queryKey, queryFn, config = {}, ...rest] = args\n\n  return [queryKey, queryFn, config, ...rest]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (\n    queryInfo.query.config.suspense ||\n    queryInfo.query.config.useErrorBoundary\n  ) {\n    if (queryInfo.query.state.status === statusError) {\n      if (!queryInfo.query.suspenseErrorHandled) {\n        queryInfo.query.suspenseErrorHandled = true\n\n        setTimeout(() => {\n          queryInfo.query.state.status = statusLoading\n        }, 0)\n\n        throw queryInfo.error\n      }\n    }\n\n    queryInfo.query.suspenseErrorHandled = false\n\n    if (queryInfo.query.config.suspense && queryInfo.status === statusLoading) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.query.fetch()\n    }\n  }\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n","import React from 'react'\nimport { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const configContext = React.createContext()\n\nconst DEFAULTS = {\n  shared: {\n    suspense: false,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n  },\n  queries: {\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    onMutate: noop,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULTS,\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = useConfigContext()\n\n  const newConfig = React.useMemo(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValue\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULTS) }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nfunction invalidQueryKey() {\n  throw new Error('A valid query key is required!')\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    invalidQueryKey()\n  }\n\n  if (!Array.isArray(queryKey)) {\n    queryKey = [queryKey]\n  }\n\n  if (queryKey.some(d => typeof d === 'function')) {\n    invalidQueryKey()\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  if (!queryHash) {\n    invalidQueryKey()\n  }\n\n  return [queryHash, queryKey]\n}\n","import React from 'react'\nimport {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n  uid,\n  statusIdle,\n  Console,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear()\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n\nconst actionInit = 'Init'\nconst actionFailed = 'Failed'\nconst actionMarkStale = 'MarkStale'\nconst actionMarkGC = 'MarkGC'\nconst actionFetch = 'Fetch'\nconst actionSuccess = 'Success'\nconst actionError = 'Error'\nconst actionSetState = 'SetState'\n\nexport function makeQueryCache({ frozen = isServer, defaultConfig } = {}) {\n  // A frozen cache does not add new queries to the cache\n  const globalListeners = []\n\n  const configRef = defaultConfig\n    ? { current: defaultConfig }\n    : defaultConfigRef\n\n  const queryCache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    queryCache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    globalListeners.forEach(d => d(queryCache))\n  }\n\n  queryCache.subscribe = cb => {\n    globalListeners.push(cb)\n    return () => {\n      globalListeners.splice(globalListeners.indexOf(cb), 1)\n    }\n  }\n\n  queryCache.clear = ({ notify = true } = {}) => {\n    Object.values(queryCache.queries).forEach(query => query.clear())\n    queryCache.queries = {}\n    if (notify) {\n      notifyGlobalListeners()\n    }\n  }\n\n  queryCache.getQueries = (predicate, { exact } = {}) => {\n    if (predicate === true) {\n      return Object.values(queryCache.queries)\n    }\n\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = configRef.current.shared.queryKeySerializerFn(predicate)\n\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(queryCache.queries).filter(predicate)\n  }\n\n  queryCache.getQuery = queryKey =>\n    queryCache.getQueries(queryKey, { exact: true })[0]\n\n  queryCache.getQueryData = queryKey =>\n    queryCache.getQuery(queryKey)?.state.data\n\n  queryCache.removeQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.clear())\n  }\n\n  queryCache.cancelQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.cancel())\n  }\n\n  queryCache.invalidateQueries = async (\n    predicate,\n    { refetchActive = true, exact, throwOnError } = {}\n  ) => {\n    try {\n      return await Promise.all(\n        queryCache.getQueries(predicate, { exact }).map(query => {\n          if (refetchActive && query.instances.length) {\n            return query.fetch()\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.buildQuery = (userQueryKey, queryFn, config = {}) => {\n    config = {\n      ...configRef.current.shared,\n      ...configRef.current.queries,\n      ...config,\n    }\n\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = queryCache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryFn, config })\n    } else {\n      query = makeQuery({\n        queryCache,\n        queryKey,\n        queryHash,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!frozen) {\n        queryCache.queries[queryHash] = query\n\n        if (isServer) {\n          notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    }\n\n    return query\n  }\n\n  queryCache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryFn,\n      config,\n      { force, throwOnError } = {},\n    ] = getQueryArgs(args)\n\n    try {\n      const query = queryCache.buildQuery(queryKey, queryFn, config)\n      if (force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.setQueryData = (queryKey, updater, config = {}) => {\n    let query = queryCache.getQuery(queryKey)\n\n    if (!query) {\n      query = queryCache.buildQuery(queryKey, () => new Promise(noop), config)\n    }\n\n    query.setData(updater)\n  }\n\n  function makeQuery({ queryCache, queryKey, queryHash, queryFn, config }) {\n    const initialData =\n      typeof config.initialData === 'function'\n        ? config.initialData()\n        : config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = !config.enabled || !hasInitialData\n\n    const initialStatus = hasInitialData\n      ? statusSuccess\n      : config.enabled\n      ? statusLoading\n      : statusIdle\n\n    let query = {\n      queryKey,\n      queryHash,\n      queryFn,\n      config,\n      instances: [],\n      state: queryReducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n      }),\n    }\n\n    query.dispatch = action => {\n      query.state = queryReducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (isServer) return\n      clearTimeout(query.staleTimeout)\n\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          query.invalidate()\n        }\n      }, query.config.staleTime)\n    }\n\n    query.invalidate = () => {\n      clearTimeout(query.staleTimeout)\n      query.dispatch({ type: actionMarkStale })\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      query.dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          queryCache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n    }\n\n    query.clearIntervals = () => {\n      query.instances.forEach(instance => {\n        instance.clearInterval()\n      })\n    }\n\n    query.setState = updater =>\n      query.dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      query.dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      clearTimeout(query.retryTimeout)\n      query.clearIntervals()\n      query.cancel()\n      query.dispatch = noop\n      delete queryCache.queries[query.queryHash]\n    }\n\n    query.subscribe = (onStateUpdate = noop) => {\n      const instance = {\n        id: uid(),\n        onStateUpdate,\n      }\n\n      query.instances.push(instance)\n\n      query.heal()\n\n      instance.clearInterval = () => {\n        clearInterval(instance.refetchIntervalId)\n        delete instance.refetchIntervalId\n      }\n\n      instance.updateConfig = config => {\n        const oldConfig = instance.config\n\n        // Update the config\n        instance.config = config\n\n        if (!isServer) {\n          if (oldConfig?.refetchInterval === config.refetchInterval) {\n            return\n          }\n\n          query.clearIntervals()\n\n          const minInterval = Math.min(\n            ...query.instances.map(d => d.config.refetchInterval || Infinity)\n          )\n\n          if (\n            !instance.refetchIntervalId &&\n            minInterval > 0 &&\n            minInterval < Infinity\n          ) {\n            instance.refetchIntervalId = setInterval(() => {\n              if (\n                isDocumentVisible() ||\n                query.instances.some(\n                  instance => instance.config.refetchIntervalInBackground\n                )\n              ) {\n                query.fetch()\n              }\n            }, minInterval)\n          }\n        }\n      }\n\n      instance.run = async () => {\n        try {\n          // Perform the refetch for this query if necessary\n          if (\n            query.config.enabled && // Don't auto refetch if disabled\n            !query.wasSuspended && // Don't double refetch for suspense\n            query.state.isStale && // Only refetch if stale\n            (query.config.refetchOnMount || query.instances.length === 1)\n          ) {\n            await query.fetch()\n          }\n\n          query.wasSuspended = false\n        } catch (error) {\n          Console.error(error)\n        }\n      }\n\n      instance.unsubscribe = () => {\n        query.instances = query.instances.filter(d => d.id !== instance.id)\n\n        if (!query.instances.length) {\n          query.clearIntervals()\n          query.cancel()\n\n          if (!isServer) {\n            // Schedule garbage collection\n            query.scheduleGarbageCollection()\n          }\n        }\n      }\n\n      return instance\n    }\n\n    // Set up the core fetcher function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n        delete query.shouldContinueRetryOnFocus\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        query.dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            query.retryTimeout = setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ __queryFn = query.queryFn } = {}) => {\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.fallbackInstance)\n          }\n\n          try {\n            // Set up the query refreshing state\n            query.dispatch({ type: actionFetch })\n\n            // Try to get the data\n            let data = await tryFetchData(__queryFn, ...query.queryKey)\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSuccess &&\n                instance.config.onSuccess(query.state.data)\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.config.onSettled &&\n                instance.config.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            query.dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onError && instance.config.onError(error)\n              )\n\n              callbackInstances.forEach(\n                instance =>\n                  instance.config.onSettled &&\n                  instance.config.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    return query\n  }\n\n  return queryCache\n}\n\nexport function queryReducer(state, action) {\n  const newState = switchActions(state, action)\n\n  Object.assign(newState, {\n    isLoading: newState.status === statusLoading,\n    isSuccess: newState.status === statusSuccess,\n    isError: newState.status === statusError,\n    isIdle: newState.status === statusIdle,\n  })\n\n  return newState\n}\n\nfunction switchActions(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching:\n          !action.hasInitialData || action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status:\n          typeof state.data !== 'undefined' ? statusSuccess : statusLoading,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.config.enabled) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n            return true\n          }\n\n          return query.config.refetchOnWindowFocus\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\nimport { useMountedCallback } from './utils'\nimport { useQueryCache } from './queryCache'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, unsafeRerender] = React.useReducer(d => d + 1, 1)\n  const rerender = useMountedCallback(unsafeRerender)\n\n  React.useEffect(() => queryCache.subscribe(rerender), [queryCache, rerender])\n\n  return React.useMemo(() => state && queryCache.isFetching, [\n    queryCache.isFetching,\n    state,\n  ])\n}\n"],"sourceRoot":""}